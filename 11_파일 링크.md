# 11_파일 링크

윈도우에 "바로가기"가 있다면 리눅스에서는 비슷한 개념으로 `링크`라는 개념이 있다.

특정 파일이나 디렉토리에 링크를 걸어서 사용하는 것이다.

링크에는 크게 두 가지가 있다.

- 하드 링크(hard link)
- 심볼릭 링크(symbolic link), 소프트 링크(soft link)

![image](https://github.com/siwon-park/Linux-Commands/assets/93081720/6503344f-82c1-4444-b00c-acdfc9f834b2)

<br>

## 1. inode

`inode`는 유닉스 계통의 파일 시스템에서 사용하는 자료 구조이다.

모든 파일과 디렉토리는 하나의 inode를 갖고 있다. 그리고 inode에는 파일의 권한과 위치 등의 중요 정보가 담겨 있다.

즉, 우리가 파일 안에 데이터가 들어있다고 생각하는 것은 사실 inode가 데이터를 담고 있는 메모리 영역을 가리키는 주소이고, 파일이 inode와 연결되어 있는 형태이다.

```bash
# 현재 파일시스템의 아이노드를 확인
df -i
```

![image](https://github.com/siwon-park/Linux-Commands/assets/93081720/5f0d1dd1-0c14-4b67-a8c9-f30a182cc7ca)

<br>

## 2. 하드 링크(Hard Link)

하드 링크는 원본 파일과 동일한 inode를 직접적으로 가리킨다. 따라서 원본 파일이 사라지더라도 데이터만 살아 있다면 원본 파일에 접근 가능하다.

따라서 원본이 삭제되어도 원본과 동일한 내용의 파일을 가지고 있으므로 자원을 공유하면서 데이터를 안전하게 관리하고자 할 때 주로 사용한다.

![image](https://github.com/siwon-park/Linux-Commands/assets/93081720/d20b833d-5b81-40c7-9425-5858c9cc7dfe)

### 1) 특징

- 코딩에서 변수 복사와 개념이 같다.
  - 원본 변수 값이 변해도 복사한 변수 값은 그대로이다.
- 동일한 파일 시스템 내에서만 하드 링크 생성 가능
- 디렉토리 링크 불가능
- 대상 파일과 동일한 inode 번호와 권한을 가짐
- 대상 파일을 옮기거나 삭제하더라도 원본 데이터를 참조 가능함
  - 사실 같은 inode를 가리키고 있기 때문에 가능

<br>

### 2) 명령어

```bash
ln [대상 파일] [하드 링크 파일]
```

하드 링크 명령어 수행 이후에 `df -i` 명령어로 inode의 수를 확인해봐도 변함이 없음을 확인할 수 있다.

<br>

## 3. 소프트 링크 / 심볼릭 링크 (Soft Link / Symbolic Link)

소프트 링크, 심볼릭 링크는 `또 다른 inode를 생성`하여 원본 데이터를 바라보게 한다. 복사되어 생성된 inode는 포인터를 가리키고, 포인터는 다시 원본 파일을 가리킨다.

따라서 파일에 작업을 할 경우 링크 그 자체에서 실행되는 것이 아니라 링크가 가리키고 있는 원본 파일에서 이루어진다.

즉, 하드 링크가 "복사"에 가까웠다면 심볼릭 링크는 "바로가기"에 가까운 개념이다. (물론 하드 링크는 실제 복사가 아님을 유의!)

![image](https://github.com/siwon-park/Linux-Commands/assets/93081720/284db036-8e8c-496d-a8cb-2258c5ba40e2)

### 1) 특징

- 파일 시스템과 대상 파일이 존재하는 파일 시스템이 달라도 생성 가능
- 파일과 디렉토리 링크 가능
- 대상 파일과 심볼릭 링크 파일은 서로 inode 번호와 권한이 다름
- 대상 파일의 inode가 아니라 대상 파일의 데이터 경로만 참조
  - 따라서 원본이 사라지면 해당 데이터에 접근할 수 없음
- 파일 종류가 `l`로 시작함

<br>

### 2) 명령어

```bash
ln -s [대상 파일] [소프트/심볼릭 링크 파일]
```

소프트 링크(심볼릭 링크) 명령어 수행 이후 `df -i` 명령어로 inode 수를 확인해보면 그 수가 증가했음을 확인할 수 있다.

<br>

## 4. 사용 목적 및 비교

### 1) 목적

왜 링크를 사용할까?

- 파일 및 디렉토리 공유
  - 링크를 통해 파일의 데이터를 공유하며, 복사를 최소화하여 공간을 절약할 수 있음
- 백업
  - 하드 링크를 사용하면 원본 파일과 동일한 데이터 블록의 백업 파일을 생성할 수 있어 디스크 공간을 절약하면서 데이터를 백업 가능함
- 버전 관리
  - 링크를 사용할 경우 특정 버전에 대한 참조를 만들어서 변경 추적을 하거나 되돌릴 수 있음
- 프로그램 설치와 실행
  - 소프트 링크(심볼릭 링크)는 여러 위치에서 동일한 실행 파일에 대한 참조를 가능하게 하여 프로그램의 설치와 실행을 간편하게 만듦
  - 시스템 관리와 소프트웨어 설치 및 유지보수 등에 활용
- 유연성 제공
  - 심볼릭 링크는 원본 파일이나 디렉토리에 대한 경로를 참조하는 것이기 때문에 다른 위치에서 참조 가능

<br>

### 2) 차이 비교 요약

| 특성              | 하드 링크                        | 심볼릭 링크                         |
| ----------------- | -------------------------------- | ----------------------------------- |
| 파일 시스템 제약  | 동일한 파일 시스템 내에서만 가능 | 다른 파일 시스템, 파티션에서도 가능 |
| 데이터 공유       | 동일한 데이터 블록을 공유        | 경로(포인터)만 저장                 |
| 크기              | 원본 파일과 동일(상대적으로 큼)  | 경로(포인터) 크기(작음)             |
| 원본 파일 삭제 시 | 데이터 유지                      | 링크가 깨져 참조 불가능             |
| 디렉토리 링크     | 비허용                           | 허용                                |

#### (1) 하드 링크

- 동일한 파일 시스템 내에서만 링크 가능 => inode 번호를 통해서 직접 파일을 참조하기 때문
- 데이터 블록 저장 => 원본 파일과 동일한 데이터 블록을 가르키며, 원본 파일이나 하드 링크 둘 중 하나를 수정하면 다른 하나에도 변경 사항이 반영됨
- 원본 파일 삭제 후에도 데이터 유지 => 원본 파일을 삭제해도 하드 링크를 통해서 원본 데이터를 참조 가능 (동일한 inode를 가르키고 있기 때문에 inode의 참조값이 0이 되지 않아서 여전히 참조 가능한 것임)
- 디렉토리 링크 불가능 => 하드 링크는 파일에만 적용 가능함. 파일 시스템의 구조와 무결성을 유지하기 위한 일종의 제한.
  - 순환 참조 방지; 디렉토리 A가 디렉토리 B를 하드 링크하고, 디렉토리 B가 디렉토리 A를 하드 링크하면 순환 참조가 발생하고, 작업에 변경에 발생했을 때 무한 루프에 빠짐.
  - 참조 카운트 관리; 디렉토리의 하드 링크를 허용하면 참조 카운트를 관리하기 어려워짐. 디렉토리 안에 있는 하위 디렉토리들에 의해 의미 없이 참조 카운트가 증가하기 때문.
  - 파일 시스템 구조 복잡성 방지; 파일 시스템은 트리 형태의 구조를 가지는데, 트리에서는 순환 참조가 존재하지 않음. 디렉토리에 하드 링크를 허용하게 되면 트리 구조가 아닌 그래프 구조가 되어 파일 시스템 구조가 매우 복잡해지는 문제가 발생함.
- 크기 => 원본 파일과 동일

#### (2) 심볼릭 링크

- 다른 파일 시스템에서도 링크 가능 => 원본 파일의 경로(포인터)를 참조하기 때문
- 경로 저장 => 실제 데이터가 아니라 경로를 저장힉 때문에 원본 파일이 이동하거나 삭제되면 심볼릭 링크는 깨지게 됨.
- 원본 파일 삭제 시 데이터 참조 불가능 => 링크가 깨져서 참조가 불가능해짐
- 디렉토리 링크 가능 => 심볼릭 링크의 장점 중 하나로 디렉토리 링크가 가능하기 때문에 파일 시스템 내에서 유연한 참조가 가능하여, 유연성을 장점으로 가지게 됨.
- 크기 => 경로(포인터)만 저장하기 때문에 크기가 원본에 비해 작음

